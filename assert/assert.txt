Go 类型断言
在 Go 语言中，类型断言（Type Assertion）是一种用于检查接口值的实际类型的机制
类型断言是 Go 语言中处理接口类型的重要工具，它允许我们从接口值中提取出具体的类型，并对其进行操作
类型断言通常用于处理接口类型的变量，因为接口变量可以存储任何实现了该接口的具体类型的值

基本语法
类型断言的基本语法如下：
value, ok := interfaceValue.(Type)
    interfaceValue 是一个接口类型的变量
    Type 是你想要断言的类型
    value 是断言成功后的具体类型的值
    ok 是一个布尔值，表示断言是否成功
如果断言成功，value 将是 interfaceValue 的实际值，ok 为 true；如果断言失败，value 将是 Type 的零值，ok 为 false

类型断言的另一种形式
除了上述的 value, ok := interfaceValue.(Type) 形式，Go 还支持另一种形式的类型断言，它不返回布尔值，而是直接在断言失败时引发 panic
这种形式的语法如下：
value := interfaceValue.(Type)

类型断言的常见用途
1. 处理多种类型的接口值
    Go 还提供了特殊的 type switch 语法来测试多种类型：
switch v := i.(type) {
case T1:
    // v的类型是T1
case T2:
    // v的类型是T2
default:
    // 默认情况
}

当接口变量可能存储多种类型的值时，类型断言可以帮助我们根据实际类型执行不同的操作
func printType(i interface{}) {
    switch v := i.(type) {
    case int:
        fmt.Println("这是一个整数:", v)
    case string:
        fmt.Println("这是一个字符串:", v)
    default:
        fmt.Println("未知类型")
    }
}

2. 从接口中提取具体类型
在处理接口类型的变量时，我们可能需要将其转换为具体的类型以便进行进一步的操作
func processInterface(i interface{}) {
    if s, ok := i.(string); ok {
        fmt.Println("处理字符串:", s)
    } else if n, ok := i.(int); ok {
        fmt.Println("处理整数:", n)
    } else {
        fmt.Println("无法处理的类型")
    }
}

注意事项
    1.类型断言只能用于接口类型：类型断言只能用于接口类型的变量，不能用于非接口类型的变量
    2.避免 panic：在使用不返回布尔值的类型断言时，务必确保类型断言不会失败，否则会引发 panic
    3.类型断言的性能：类型断言在运行时进行类型检查，因此可能会带来一定的性能开销。在性能敏感的场景中，应谨慎使用